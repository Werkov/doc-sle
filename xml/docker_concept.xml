<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE chapter
[
  <!ENTITY % entities SYSTEM "entity-decl.ent">
    %entities;
]>
<chapter xml:id="cha.docker.conceptoverview" xml:lang="en"
 xmlns="http://docbook.org/ns/docbook" version="5.0"
 xmlns:xi="http://www.w3.org/2001/XInclude"
 xmlns:xlink="http://www.w3.org/1999/xlink">
  <title>Conceptual Overview</title>
 <para>
  &deng; is a lightweight virtualization solution to run multiple virtual units
  (containers) simultaneously on a single control host. Containers are isolated
  with Kernel Control Groups (<xref linkend="vle.docker.cgroup"/>) and
  <xref linkend="vle.docker.namespace"/>.
 </para>
 <para>
  Full virtualization solutions such as &xen;, &kvm;, or &libvirt; are based on
  the processor simulating a complete hardware environment and controlling the
  virtual machines. However, &deng; only provides operating system-level
  virtualization where the Linux kernel controls isolated containers.
 </para>
 <sect1 xml:id="sec.docker.installation.terminology_deng">
  <title>Terminology</title>
  <para>
   Before going into detail about &deng;, let us define some of the terms used:
  </para>
  <variablelist>
   <varlistentry>
    <term>Container</term>
    <listitem>
     <para>
      A <emphasis>container</emphasis> is an instance based on a particular
      <xref linkend="Docker_Image"/> within an execution environment with a set
      of instructions. Each <emphasis>container</emphasis> can be distinguished
      by a unique container ID.
     </para>
    </listitem>
   </varlistentry>
   <varlistentry xml:id="vle.docker.cgroup">
    <term>Control group</term>
    <listitem>
     <para>
      <emphasis>Control groups</emphasis>, also called
      <literal>cgroups</literal>, are a Linux kernel feature that allows
      aggregating or partitioning tasks (processes) and all their children into
      hierarchically organized groups in order to isolate resources.
     </para>
    </listitem>
   </varlistentry>
   <varlistentry xml:id="Dockerfile">
    <term>Dockerfile</term>
    <listitem>
     <para>
      A text document which contains commands to assemble a &docker; image. With
      the <command>docker build</command> command, the instructions provided in
      the <emphasis>Dockerfile</emphasis> are executed by the
      <xref linkend="Docker_engine"/> to create a <xref linkend="Docker_Image"/>.
      The <emphasis>Dockerfile</emphasis> can store modifications you want to
      apply to the resulting image on top of a base image.
     </para>
    </listitem>
   </varlistentry>
   <varlistentry xml:id="Docker_Image">
    <term>&docker; Image</term>
    <listitem>
     <para>
      A self-contained piece of software. A <emphasis>&docker; image</emphasis>
      is a read-only template used to create a
      <emphasis>virtual machine</emphasis> on the host server. The
      <emphasis>image</emphasis> is built with a <xref linkend="Dockerfile"/>
      and is made by a series of layers built one over the other. Each layer
      corresponds to a permanent modification, for example an update of an
      application. For more details on Docker images, see
      <link xlink:href="http://docs.docker.com/engine/reference/glossary#image">
       the official Docker documentation</link>.
     </para>
    </listitem>
   </varlistentry>
   <varlistentry xml:id="Docker_engine">
    <term>&deng;</term>
    <listitem>
     <para>
      A server-client type application that performs all tasks related to
      virtual machines. &deng; comprises the following:
     </para>
     <itemizedlist>
      <listitem>
       <formalpara>
        <title>CLI Client:</title>
        <para>
         Enables you to communicate with the daemon. If the daemon is running
         on a different machine than the CLI client, the CLI client can
         communicate by using network sockets or the REST API provided by
         &deng;.
        </para>
       </formalpara>
      </listitem>
      <listitem>
       <formalpara>
        <title>Daemon:</title>
        <para>
         The server side of &deng; manages all &docker; objects (images,
         containers, network connections used by containers, etc.).
        </para>
       </formalpara>
      </listitem>
      <listitem>
       <formalpara>
        <title>REST API:</title>
        <para>
         An API which can be used to directly communicate with the daemon.
        </para>
       </formalpara>
      </listitem>
     </itemizedlist>
    </listitem>
   </varlistentry>
   <varlistentry xml:id="Docker_layer">
    <term>Layer</term>
    <listitem>
     <para>
      An <emphasis>image</emphasis> which is created during the
      <command>docker build</command> process after each instruction. Each
      <emphasis>layer</emphasis> is a separate read-only image, except the last
      which is a read/write layer.
     </para>
    </listitem>
   </varlistentry>
   <varlistentry xml:id="vle.docker.namespace">
    <term>Namespace</term>
    <listitem>
     <para>
      Used by &deng; for its containers to isolate resources reserved for
      particular containers from other containers or the host system.
     </para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term>Orchestration</term>
    <listitem>
     <para>
      In a production environment you typically need a cluster with many
      containers on each cluster node. The containers must cooperate and you
      need a framework that enables you to manage the containers automatically.
      The act of automatic container management is called <emphasis>container
      orchestration</emphasis> and is typically handled by Kubernetes.
     </para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term>Registry</term>
    <listitem>
     <para>
      A storage and content distribution for already created images. It
      typically contains several <emphasis>repositories</emphasis>. There are
      two types of registry:
     </para>
     <itemizedlist>
      <listitem>
       <formalpara>
        <title>Private Registry:</title>
        <para>
         Only accessible for particular users or users from a particular private
         network<phrase os="sles;sled">, for example <link
          xlink:href="https://registry.suse.com"/></phrase>.
        </para>
       </formalpara>
      </listitem>
      <listitem>
       <formalpara>
        <title>Public Registry:</title>
        <para>
         Everyone can download and use images. A typical public registry is
         <link xlink:href="https://hub.docker.com/">Docker Hub</link><phrase
          os="osuse"> or <link xlink:href="registry.opensuse.org"/></phrase>.
        </para>
       </formalpara>
      </listitem>
     </itemizedlist>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term>Repository</term>
    <listitem>
     <para>
      A storage in a <emphasis>registry</emphasis> that stores a different
      version of a particular image. You can pull images from a repository or
      push images to a repository.
     </para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term>Tag</term>
    <listitem>
     <para>
      An alias for an <emphasis>image</emphasis>. When an
      <emphasis>image</emphasis> is built, each image layer has a unique
      identifier. The final image (layer) can be tagged to make it simple to
      find and reference, instead of having to use the identifier. If an image
      is not tagged during the build process, its tag defaults to
      <quote>latest</quote>.
     </para>
    </listitem>
   </varlistentry>
  </variablelist>

 </sect1>
 <sect1 xml:id="sec.docker.concept.advantages_deng">
  <title>Advantages of &deng;</title>
  <para>
   &deng; has the following advantages:
  </para>
  <itemizedlist>
   <listitem>
    <para>
     Isolates applications and operating systems through containers.
    </para>
   </listitem>
   <listitem>
    <para>
     Manages allocation of resources in real time, leading to a near-native performance.
    </para>
   </listitem>
   <listitem>
    <para>
     Uses cgroups to control network interfaces and resources available inside containers.
    </para>
   </listitem>
   <listitem>
    <para>
     Versioning of images.
    </para>
   </listitem>
   <listitem>
    <para>
     Allows building new images based on existing ones.
    </para>
   </listitem>
   <listitem>
    <para>
     Provides you with container orchestration.
    </para>
   </listitem>
  </itemizedlist>
 </sect1>
 <sect1 xml:id="sec.docker.concept.limitations_deng">
  <title>Limitations of &deng;</title>
  <para>
   &deng; has the following limitations:
  </para>
  <itemizedlist mark="bullet" spacing="normal">
   <listitem>
    <para>
     Containers run inside the host system's kernel and cannot use a different
     kernel.
    </para>
   </listitem>
   <listitem>
    <para>
     Only allows Linux <emphasis>guest</emphasis> operating systems.
    </para>
   </listitem>
   <listitem>
    <para>
     &deng; is not a full virtualization stack like &xen;, &kvm;, or &libvirt;.
    </para>
   </listitem>
   <listitem>
    <para>
     Security depends on the host system. Refer to the
     <link xlink:href="http://docs.docker.com/articles/security/">official
      security documentation</link> for more details.
    </para>
   </listitem>
  </itemizedlist>
 </sect1>
 <sect1 xml:id="sec.docker.concept.images-applications">
  <title>&docker; Images of Applications</title>
  <para>
  &deng; is a technology that can help minimize resources used to run or
  build applications. There are several types of applications that are
  suitable to run inside a &docker; container, like daemons, Web pages or
  applications that expose ports for communication. You can use &deng; to
  automate building and deployment processes by adding the build process
  into a &docker; image, then building the image and then running containers
  based on that image.
 </para>
 <sect2 xml:id="sec.docker.concept.images-applications.run-inside">
  <title>Advantages of Running Applications Inside &docker; Containers</title>
  <para>
   Running an application inside a &docker; container has the
   following advantages:
  </para>
  <itemizedlist>
   <listitem>
    <para>
     You can minimize the runtime environment of the application by adding only
     the required processes and applications to the &docker; image.
    </para>
   </listitem>
   <listitem>
    <para>
     Images of an application are portable across machines with
     different Linux host systems.
    </para>
   </listitem>
   <listitem>
    <para>
     You can share an image of an application using a repository.
    </para>
   </listitem>
   <listitem>
    <para>
     User-space software running within the container is independent from the
     user-space software running on the host system. This avoids issues such as
     library incompatibilities.
    </para>
   </listitem>
   <listitem>
    <para>
     You can run several instances of the same application that are completely
     independent from each other.
    </para>
   </listitem>
  </itemizedlist>
  </sect2>
  <sect2 xml:id="sec.docker.concept.images-applications.build">
   <title>Advantages of &deng; to Build Applications</title>
   <para>
    Using &deng; to build applications has the following advantages:
   </para>
   <itemizedlist>
    <listitem>
     <para>
      You can prepare a complete build image.
     </para>
    </listitem>
    <listitem>
     <para>
      Your build always runs in the same environment.
     </para>
    </listitem>
    <listitem>
     <para>
      Developers can test their code in the same environment that is used in
      production.
     </para>
    </listitem>
    <listitem>
     <para>
      You can set up an automated building process.
     </para>
    </listitem>
   </itemizedlist>
  </sect2>
 </sect1>
 <sect1 xml:id="sec.docker.concept.architecture_deng">
  <title>&deng; Architecture</title>
  <para>
   &deng; uses a client/server architecture. You can use the <emphasis>CLI
    client</emphasis> to communicate with the <emphasis>daemon</emphasis>. The
   <emphasis>daemon</emphasis> then performs operations with containers and
   manages images locally or in the registry. The <emphasis>CLI client</emphasis>
   can run on the same server as the host daemon or on a different machine. The
   <emphasis>CLI client</emphasis> communicates with the
   <emphasis>daemon</emphasis> by using network sockets. The architecture is
   depicted in <xref linkend="Docker_architecture"/>.
  </para>
  <figure xml:id="Docker_architecture">
   <title>The &deng; Architecture</title>
   <mediaobject>
    <imageobject>
     <imagedata fileref="docker_architecture.png" format="PNG" width="95%"/>
    </imageobject>
   </mediaobject>
  </figure>
 </sect1>

 <sect1 xml:id="sec.docker.concept.definition_dreg">
  <title>&dreg;</title>

  <para>
   The &dreg; is an open-source project created by Docker Inc. It
   allows the storage and retrieval of &docker; images. By running a local
   instance of the &dreg;, it is possible to completely avoid usage of &dhub;.
  </para>

  <para>
   &dreg; is also used by &dhub;. However, &dhub;,
   as seen from the user perspective, is made of the following parts at least:
  </para>

  <remark>toms 2019-02-05: Not sure if it is better to have separate sections
  about terminology instead of one single one at the beginning.
  Maybe you need to rephrase it to make it clear that the terms below refers
  to the Docker Registry. Discuss with Tanja. :)
  </remark>
  <sect2 xml:id="sec.docker.concept.terminology_dreg">
   <title>&dreg; Terminology</title>
   <variablelist>
    <varlistentry>
     <term>
      Authentication Component
     </term>
     <listitem>
      <para>
       Used to protect the images stored inside of &dhub;. It validates all
       push, pull and search requests.
      </para>
      <para>
       This component is closed-source.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>
      Storage Back-End
     </term>
     <listitem>
      <para>
       Where &docker; images are sent and downloaded from. It is provided by
       &dreg;.
      </para>
      <para>
       This component is open-source.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>
      User Interface (UI)
     </term>
     <listitem>
      <para>
       Accessed by users with their browser that allows exploring the contents of
       &dhub; either through browsing or using search and allows managung users
       and organizations.
      </para>
      <para>
       This component is closed-source.
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </sect2>
  <sect2 xml:id="sec.docker.concept.limitations_dreg">
   <title>Limitations of &dreg;</title>

   <para>
    The &dreg; has two major limitations:
   </para>

   <itemizedlist>
    <listitem>
     <para>
      It lacks any form of authentication. That means everybody with access to
      the &dreg; can push and pull images to it. That also includes the
      possibility to overwrite already existing images.
     </para>
    </listitem>
    <listitem>
     <para>
      There is no way to see which images have been pushed to the &dreg;.
      You need to manually take notes of what is being stored inside
      of it. There is also no search functionality, which makes collaboration
      harder.
     </para>
    </listitem>
   </itemizedlist>
  </sect2>
 </sect1>
</chapter>
